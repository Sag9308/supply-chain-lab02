name: supply-chain

on:
  push:
    branches: [ "main" ]

permissions:
  contents: read
  packages: write
  id-token: write   # OIDC for keyless cosign signing
  attestations: write # für actions/attest-build-provenance@v1 API Call via Github Attestation zu persistieren

env:
  IMAGE_NAME: ghcr.io/${{ (github.repository_owner) }}/supply-chain-app
  TAG: ${{ github.sha }}

jobs:
  supply-chain:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Normalize IMAGE_NAME to lowercase
        run: |
          echo "IMAGE_NAME=ghcr.io/${GITHUB_REPOSITORY_OWNER,,}/supply-chain-app" >> $GITHUB_ENV
          echo "Using IMAGE_NAME=ghcr.io/${GITHUB_REPOSITORY_OWNER,,}/supply-chain-app"


      # -------------------------
      # 1) Tooling installieren
      # -------------------------
      - name: Install cosign
        uses: sigstore/cosign-installer@v3.6.0

      - name: Install syft
        uses: anchore/sbom-action/download-syft@v0.16.0

      - name: Install trivy (CLI)
        run: |
          sudo apt-get update
          sudo apt-get install -y wget gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo gpg --dearmor -o /usr/share/keyrings/trivy.gpg
          echo "deb [signed-by=/usr/share/keyrings/trivy.gpg] https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install -y trivy
          trivy --version

      - name: Install semgrep
        run: |
          python3 -m pip install --upgrade pip
          pip install semgrep

      - name: Install checkov
        run: |
          python3 -m pip install --upgrade pip
          pip install checkov

      # -------------------------
      # 2) Security Scanning (5 Scans)
      #    Fail if HIGH/CRITICAL > 0
      # -------------------------

      # (1) SAST - Semgrep
      - name: SAST (Semgrep) - fail on findings
        run: |
          semgrep --version
          # Beispiel-Regeln: "p/default" ist guter Start.
          # Optional später: eigene ruleset/policy
          semgrep scan --config "p/default" --error

      # (2) Dependency / filesystem scan (SCA)
      - name: SCA (Trivy fs) - fail on HIGH/CRITICAL
        run: |
          trivy fs --exit-code 1 --severity HIGH,CRITICAL --no-progress .

      # (3) Dockerfile / config scan
      - name: Dockerfile/Config (Trivy config) - fail on HIGH/CRITICAL
        run: |
          trivy config --exit-code 1 --severity HIGH,CRITICAL .

      # (4) IaC Scan (Checkov) - fail on HIGH/CRITICAL
      - name: IaC (Checkov) - fail on HIGH/CRITICAL
        run: |
          # Checkov hat unterschiedliche Policies; wir machen strikt.
          # Falls dein Repo viel "Noise" hat, später gezielt skip/soften.
          checkov -d src/iac --quiet --skip-check CKV2_AWS_5

      # (5) Kubernetes Manifests (Trivy)
      - name: K8s Manifests (Trivy)
        run: |
          trivy config src/k8s --exit-code 1 --severity HIGH,CRITICAL

      # -------------------------
      # 3) Build & Push (with provenance + SBOM via BuildKit)
      # -------------------------
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & Push (BuildKit provenance + SBOM)
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ./src
          file: ./src/docker/Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:${{ env.TAG }}
            ${{ env.IMAGE_NAME }}:latest
          provenance: true
          sbom: true

      - name: Capture digest
        id: digest
        run: |
          echo "DIGEST=${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT
          echo "IMAGE_REF=${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT
          echo "Built image ref: ${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}"

      - name: Attest build provenance (SLSA)
        uses: actions/attest-build-provenance@v1
        with:
          subject-name: ${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.build.outputs.digest }}
          push-to-registry: true
 
      # -------------------------
      # 4) Create extra attestations:
      #    - SBOM (Syft)
      #    - 3x vulnerability attestations (Trivy) for: image + fs + config
      # -------------------------
      - name: Generate SBOM (SPDX JSON)
        run: |
          syft "${{ steps.digest.outputs.IMAGE_REF }}" -o spdx-json > sbom.spdx.json

      - name: Vulnerability report #1 (Trivy image)
        run: |
          set -euo pipefail
          trivy image --format json --output vuln-image.json \
            --severity HIGH,CRITICAL --no-progress "${{ steps.digest.outputs.IMAGE_REF }}" || true
            test -s vuln-image.json
            echo "Created vuln-image.json"

      - name: Vulnerability report #2 (Trivy fs JSON)
        run: |
          set -euo pipefail
          trivy fs --format json --output vuln-fs.json \
            --severity HIGH,CRITICAL --no-progress . || true
          test -s vuln-fs.json
          echo "Created vuln-fs.json"

      - name: Vulnerability report #3 (Trivy config JSON)
        run: |
          set -euo pipefail
          trivy config --format json --output vuln-config.json \
            --severity HIGH,CRITICAL --quiet . || true
          test -s vuln-config.json
          echo "Created vuln-config.json"

      # Hard gate: image vulnerabilities must be zero HIGH/CRITICAL too
      - name: Enforce image vuln gate (HIGH/CRITICAL must be 0)
        run: |
          trivy image --exit-code 1 --severity HIGH,CRITICAL --no-progress "${{ steps.digest.outputs.IMAGE_REF }}"

      - name: Debug – list generated reports
        run: |
          ls -la
          ls -la vuln-*.json sbom.spdx.json
      # -------------------------
      # 5) Keyless signing with GitHub OIDC (cosign)
      #    Sign image + attestations
      # -------------------------
      - name: Cosign sign image (keyless, Rekor upload)
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          cosign version
          cosign sign --yes "${{ steps.digest.outputs.IMAGE_REF }}"

      - name: Cosign attest SBOM (SPDX)
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          cosign attest --yes \
            --predicate sbom.spdx.json \
            --type spdx \
            "${{ steps.digest.outputs.IMAGE_REF }}"

      - name: Cosign attest vuln #1 (image)
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          cosign attest --yes \
            --predicate vuln-image.json \
            --type vuln \
            "${{ steps.digest.outputs.IMAGE_REF }}"

      - name: Cosign attest vuln #2 (fs)
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          cosign attest --yes \
            --predicate vuln-fs.json \
            --type vuln \
            "${{ steps.digest.outputs.IMAGE_REF }}"

      - name: Cosign attest vuln #3 (config)
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          cosign attest --yes \
            --predicate vuln-config.json \
            --type vuln \
            "${{ steps.digest.outputs.IMAGE_REF }}"

      # -------------------------
      # 6) Verification (policy-like checks)
      #    - verfify provenance
      #    - verify image signature
      #    - verify attestations
      #    - check Rekor entries (expect 6)
      # -------------------------
      - name: Verify image signature (identity bound to workflow)
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          # Wir pinnen Identität auf den Workflow + Repo.
          # Das ist genau der "Cloud-Security" Teil: nicht nur "is signed",
          # sondern "signed by OUR pipeline".
          cosign verify \
            --certificate-identity-regexp "https://github.com/${{ github.repository }}/.github/workflows/supply-chain.yml@refs/heads/main" \
            --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
            "${{ steps.digest.outputs.IMAGE_REF }}"

      - name: Verify attestations exist
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          # SBOM
          cosign verify-attestation \
            --type spdx \
            --certificate-identity-regexp "https://github.com/${{ github.repository }}/.github/workflows/supply-chain.yml@refs/heads/main" \
            --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
            "${{ steps.digest.outputs.IMAGE_REF }}" >/dev/null

          # Vulnerability attestations (3 Stück vorhanden)
          # Wir prüfen hier presence; in einer Härtung würdest du auch Inhalte auswerten.
          cosign verify-attestation \
            --type vuln \
            --certificate-identity-regexp "https://github.com/${{ github.repository }}/.github/workflows/supply-chain.yml@refs/heads/main" \
            --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
            "${{ steps.digest.outputs.IMAGE_REF }}" >/dev/null

      - name: Install rekor-cli
        run: |
          curl -sSfL https://github.com/sigstore/rekor/releases/latest/download/rekor-cli-linux-amd64 \
          -o rekor-cli
          chmod +x rekor-cli
          sudo mv rekor-cli /usr/local/bin/rekor-cli
          rekor-cli version
          
      - name: Check Rekor entries (expect >=6)
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          #nicht nach digest suchen, sondern nach image_ref - es kann nämlich sein, dass der img_digest bei manchen artefakten gar nicht drin ist
          set -euo pipefail
          IMG="${{ steps.digest.outputs.IMAGE_REF }}"

          #1) Image signature logIndex
          SIG_COUNT=$(cosign verify \
            --certificate-identity-regexp "https://github.com/${{ github.repository }}/.github/workflows/supply-chain.yml@refs/heads/main" \
            --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
            --output json "$IMG" 2>/dev/null \
            | jq -r '.. | .logIndex? // empty' \
            | wc -l | tr -d ' ')
                 
          #2) Attestations logIndex zählen (spdx + vuln + slsa provenance)
          ATT_COUNT=$(
            {
              cosign verify-attestation \
                --type spdx \
                --certificate-identity-regexp "https://github.com/${{ github.repository }}/.github/workflows/supply-chain.yml@refs/heads/main" \
                --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
                --output json "$IMG" 2>/dev/null

              cosign verify-attestation \
                --type vuln \
                --certificate-identity-regexp "https://github.com/${{ github.repository }}/.github/workflows/supply-chain.yml@refs/heads/main" \
                --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
                --output json "$IMG" 2>/dev/null

              cosign verify-attestation \
                --type slsaprovenance \
                --certificate-identity-regexp "https://github.com/${{ github.repository }}/.github/workflows/supply-chain.yml@refs/heads/main" \
                --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
                --output json "$IMG" 2>/dev/null
          } | jq -r '.. | .logIndex? // empty' | wc -l | tr -d ' '
          )
          
          TOTAL=$((SIG_COUNT + ATT_COUNT))
          echo "Rekor entries (from cosign bundles): signature=$SIG_COUNT attestations=$ATT_COUNT total=$TOTAL"

          #Erwartung: 6 Entries = 1 Signatur + 5 Attestations
          #(je nach Registry/OCI-Mode kann es leicht variieren, aber Ziel ist 6)
          if [ "$TOTAL" -lt 6 ]; then
            echo "WARN: Expected at least 6 Rekor entries but got $TOTAL (may vary due to bundling)"
            exit 0
          fi

      - name: Check signatures/attestations + Rekor logging
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          IMG="${{ steps.digest.outputs.IMAGE_REF }}"
          ID_RE="https://github.com/${{ github.repository }}/.github/workflows/supply-chain.yml@refs/heads/main"
          ISSUER="https://token.actions.githubusercontent.com"

          echo "Checking for image: $IMG"

          #1) Image signature exists + is logged in Rekor (logIndex present)
          SIG_JSON=$(cosign verify \
            --certificate-identity-regexp "$ID_RE" \
            --certificate-oidc-issuer "$ISSUER" \
            --output json "$IMG")

          SIG_COUNT=$(echo "$SIG_JSON" | jq 'length')
          SIG_LOGGED=$(echo "$SIG_JSON" | jq '[.[].bundle.payload.logIndex? // empty] | length')
          
          echo "Signature count: $SIG_COUNT"
          echo "Signatures with Rekor logIndex: $SIG_LOGGED"
          
          if [ "$SIG_COUNT" -lt 1 ]; then
            echo "ERROR: No signatures found"
            exit 1
          fi
          if [ "$SIG_LOGGED" -lt 1 ]; then
            echo "ERROR: Signature not logged to Rekor (no logIndex)"
            exit 1
          fi

          # 2) SBOM attestation exists + logged
          SBOM_JSON=$(cosign verify-attestation \
            --type spdx \
            --certificate-identity-regexp "$ID_RE" \
            --certificate-oidc-issuer "$ISSUER" \
            --output json "$IMG")
          
          SBOM_COUNT=$(echo "$SBOM_JSON" | jq 'length')
          SBOM_LOGGED=$(echo "$SBOM_JSON" | jq '[.[].bundle.payload.logIndex? // empty] | length')
          
          echo "SBOM attestations: $SBOM_COUNT"
          echo "SBOM attestations with Rekor logIndex: $SBOM_LOGGED"
          
          if [ "$SBOM_COUNT" -lt 1 ]; then
            echo "ERROR: Missing SBOM (spdx) attestation"
            exit 1
          fi
          if [ "$SBOM_LOGGED" -lt 1 ]; then
            echo "ERROR: SBOM attestation not logged to Rekor"
            exit 1
          fi

          # 3) Vulnerability attestations (expect at least 3) + logged
          VULN_JSON=$(cosign verify-attestation \
            --type vuln \
            --certificate-identity-regexp "$ID_RE" \
            --certificate-oidc-issuer "$ISSUER" \
            --output json "$IMG")
          
          VULN_COUNT=$(echo "$VULN_JSON" | jq 'length')
          VULN_LOGGED=$(echo "$VULN_JSON" | jq '[.[].bundle.payload.logIndex? // empty] | length')
          
          echo "Vuln attestations: $VULN_COUNT"
          echo "Vuln attestations with Rekor logIndex: $VULN_LOGGED"
          
          if [ "$VULN_COUNT" -lt 3 ]; then
            echo "ERROR: Expected at least 3 vuln attestations, got $VULN_COUNT"
            exit 1
          fi
          if [ "$VULN_LOGGED" -lt 3 ]; then
            echo "ERROR: Not all vuln attestations appear logged to Rekor"
            exit 1
          fi

          # 4) Provenance (SLSA) — depends how you create it
          # If you're using actions/attest-build-provenance, it creates a GitHub attestation
          # and may also push to registry. Cosign type might be "slsaprovenance" or "provenance".
          # We'll try both (don't fail on first).
          set +e
          cosign verify-attestation \
            --type slsaprovenance \
            --certificate-identity-regexp "$ID_RE" \
            --certificate-oidc-issuer "$ISSUER" \
            --output json "$IMG" >/tmp/prov.json 2>/dev/null
          RC=$?
          if [ $RC -ne 0 ]; then
            cosign verify-attestation \
              --type provenance \
              --certificate-identity-regexp "$ID_RE" \
              --certificate-oidc-issuer "$ISSUER" \
              --output json "$IMG" >/tmp/prov.json
            RC=$?
          fi
          set -e
        
          if [ $RC -ne 0 ]; then
            echo "ERROR: Missing provenance attestation (type slsaprovenance/provenance)"
            exit 1
          fi
        
          PROV_COUNT=$(cat /tmp/prov.json | jq 'length')
          PROV_LOGGED=$(cat /tmp/prov.json | jq '[.[].bundle.payload.logIndex? // empty] | length')
          echo "Provenance attestations: $PROV_COUNT"
          echo "Provenance attestations with Rekor logIndex: $PROV_LOGGED"
        
          if [ "$PROV_LOGGED" -lt 1 ]; then
            echo "ERROR: Provenance attestation not logged to Rekor"
            exit 1
          fi
        
          echo "All checks passed ✅"

